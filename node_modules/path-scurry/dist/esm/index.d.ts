/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import { LRUCache } from 'lru-cache';
import { posix, win32 } from 'path';
import type { Dirent, Stats } from 'fs';
import { Minipass } from 'minipass';
/**
 * An object that will be used to override the default `fs`
 * methods.  Any methods that are not overridden will use Node's
 * built-in implementations.
 *
 * - lstatSync
 * - readdir (callback `withFileTypes` Dirent variant, used for
 *   readdirCB and most walks)
 * - readdirSync
 * - readlinkSync
 * - realpathSync
 * - promises: Object containing the following async methods:
 *   - lstat
 *   - readdir (Dirent variant only)
 *   - readlink
 *   - realpath
 */
export interface FSOption {
    lstatSync?: (path: string) => Stats;
    readdir?: (path: string, options: {
        withFileTypes: true;
    }, cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any) => void;
    readdirSync?: (path: string, options: {
        withFileTypes: true;
    }) => Dirent[];
    readlinkSync?: (path: string) => string;
    realpathSync?: (path: string) => string;
    promises?: {
        lstat?: (path: string) => Promise<Stats>;
        readdir?: (path: string, options: {
            withFileTypes: true;
        }) => Promise<Dirent[]>;
        readlink?: (path: string) => Promise<string>;
        realpath?: (path: string) => Promise<string>;
        [k: string]: any;
    };
    [k: string]: any;
}
interface FSValue {
    lstatSync: (path: string) => Stats;
    readdir: (path: string, options: {
        withFileTypes: true;
    }, cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any) => void;
    readdirSync: (path: string, options: {
        withFileTypes: true;
    }) => Dirent[];
    readlinkSync: (path: string) => string;
    realpathSync: (path: string) => string;
    promises: {
        lstat: (path: string) => Promise<Stats>;
        readdir: (path: string, options: {
            withFileTypes: true;
        }) => Promise<Dirent[]>;
        readlink: (path: string) => Promise<string>;
        realpath: (path: string) => Promise<string>;
        [k: string]: any;
    };
    [k: string]: any;
}
export type Type = 'Unknown' | 'FIFO' | 'CharacterDevice' | 'Directory' | 'BlockDevice' | 'File' | 'SymbolicLink' | 'Socket';
/**
 * Options that may be provided to the Path constructor
 */
export interface PathOpts {
    fullpath?: string;
    relative?: string;
    relativePosix?: string;
    parent?: PathBase;
    /**
     * See {@link FSOption}
     */
    fs?: FSOption;
}
/**
 * An LRUCache for storing resolved path strings or Path objects.
 * @internal
 */
export declare class ResolveCache extends LRUCache<string, string> {
    constructor();
}
/**
 * an LRUCache for storing child entries.
 * @internal
 */
export declare class ChildrenCache extends LRUCache<PathBase, Children> {
    constructor(maxSize?: number);
}
/**
 * Array of Path objects, plus a marker indicating the first provisional entry
 *
 * @internal
 */
export type Children = PathBase[] & {
    provisional: number;
};
declare const setAsCwd: unique symbol;
/**
 * Path objects are sort of like a super-powered
 * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}
 *
 * Each one represents a single filesystem entry on disk, which may or may not
 * exist. It includes methods for reading various types of information via
 * lstat, readlink, and readdir, and caches all information to the greatest
 * degree possible.
 *
 * Note that fs operations that would normally throw will instead return an
 * "empty" value. This is in order to prevent excessive overhead from error
 * stack traces.
 */
export declare abstract class PathBase implements Dirent {
    #private;
    /**
     * the basename of this path
     *
     * **Important**: *always* test the path name against any test string
     * usingthe {@link isNamed} method, and not by directly comparing this
     * string. Otherwise, unicode path strings that the system sees as identical
     * will not be properly treated as the same path, leading to incorrect
     * behavior and possible security issues.
     */
    name: string;
    /**
     * the Path entry corresponding to the path root.
     *
     * @internal
     */
    root: PathBase;
    /**
     * All roots found within the current PathScurry family
     *
     * @internal
     */
    roots: {
        [k: string]: PathBase;
    };
    /**
     * a reference to the parent path, or undefined in the case of root entries
     *
     * @internal
     */
    parent?: PathBase;
    /**
     * boolean indicating whether paths are compared case-insensitively
     * @internal
     */
    nocase: boolean;
    /**
     * the string or regexp used to split paths. On posix, it is `'/'`, and on
     * windows it is a RegExp matching either `'/'` or `'\\'`
     */
    abstract splitSep: string | RegExp;
    /**
     * The path separator string to use when joining paths
     */
    abstract sep: string;
    get dev(): number | undefined;
    get mode(): number | undefined;
    get nlink(): number | undefined;
    get uid(): number | undefined;
    get gid(): number | undefined;
    get rdev(): number | undefined;
    get blksize(): number | undefined;
    get ino(): number | undefined;
    get size(): number | undefined;
    get blocks(): number | undefined;
    get atimeMs(): number | undefined;
    get mtimeMs(): number | undefined;
    get ctimeMs(): number | undefined;
    get birthtimeMs(): number | undefined;
    get atime(): Date | undefined;
    get mtime(): Date | undefined;
    get ctime(): Date | undefined;
    get birthtime(): Date | undefined;
    /**
     * This property is for compatibility with the Dirent class as of
     * Node v20, where Dirent['path'] refers to the path of the directory
     * that was passed to readdir.  So, somewhat counterintuitively, this
     * property refers to the *parent* path, not the path object itself.
     * For root entries, it's the path to the entry itself.
     */
    get path(): string;
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name: string, type: number | undefined, root: PathBase | undefined, roots: {
        [k: string]: PathBase;
    }, nocase: boolean, children: ChildrenCache, opts: PathOpts);
    /**
     * Returns the depth of the Path object from its root.
     *
     * For example, a path at `/foo/bar` would have a depth of 2.
     */
    depth(): number;
    /**
     * @internal
     */
    abstract getRootString(path: string): string;
    /**
     * @internal
     */
    abstract getRoot(rootPath: string): PathBase;
    /**
     * @internal
     */
    abstract newChild(name: string, type?: number, opts?: PathOpts): PathBase;
    /**
     * @internal
     */
    childrenCache(): ChildrenCache;
    /**
     * Get the Path object referenced by the string path, resolved from this Path
     */
    resolve(path?: string): PathBase;
    /**
     * Returns the cached children Path objects, if still available.  If they
     * have fallen out of the cache, then returns an empty array, and resets the
     * READDIR_CALLED bit, so that future calls to readdir() will require an fs
     * lookup.
     *
     * @internal
     */
    children(): Children;
    /**
     * Resolves a path portion and returns or creates the child Path.
     *
     * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
     * `'..'`.
     *
     * This should not be called directly.  If `pathPart` contains any path
     * separators, it will lead to unsafe undefined behavior.
     *
     * Use `Path.resolve()` instead.
     *
     * @internal
     */
    child(pathPart: string, opts?: PathOpts): PathBase;
    /**
     * The relative path from the cwd. If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpath()
     */
    relative(): string;
    /**
     * The relative path from the cwd, using / as the path separator.
     * If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpathPosix()
     * On posix systems, this is identical to relative().
     */
    relativePosix(): string;
    /**
     * The fully resolved path string for this Path entry
     */
    fullpath(): string;
    /**
     * On platforms other than windows, this is identical to fullpath.
     *
     * On windows, this is overridden to return the forward-slash form of the
     * full UNC path.
     */
    fullpathPosix(): string;
    /**
     * Is the Path of an unknown type?
     *
     * Note that we might know *something* about it if there has been a previous
     * filesystem operation, for example that it does not exist, or is not a
     * link, or whether it has child entries.
     */
    isUnknown(): boolean;
    isType(type: Type): boolean;
    getType(): Type;
    /**
     * Is the Path a regular file?
     */
    isFile(): boolean;
    /**
     * Is the Path a directory?
     */
    isDirectory(): boolean;
    /**
     * Is the path a character device?
     */
    isCharacterDevice(): boolean;
    /**
     * Is the path a block device?
     */
    isBlockDevice(): boolean;
    /**
     * Is the path a FIFO pipe?
     */
    isFIFO(): boolean;
    /**
     * Is the path a socket?
     */
    isSocket(): boolean;
    /**
     * Is the path a symbolic link?
     */
    isSymbolicLink(): boolean;
    /**
     * Return the entry if it has been subject of a successful lstat, or
     * undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* simply
     * mean that we haven't called lstat on it.
     */
    lstatCached(): PathBase | undefined;
    /**
     * Return the cached link target if the entry has been the subject of a
     * successful readlink, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readlink() has been called at some point.
     */
    readlinkCached(): PathBase | undefined;
    /**
     * Returns the cached realpath target if the entry has been the subject
     * of a successful realpath, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * realpath() has been called at some point.
     */
    realpathCached(): PathBase | undefined;
    /**
     * Returns the cached child Path entries array if the entry has been the
     * subject of a successful readdir(), or [] otherwise.
     *
     * Does not read the filesystem, so an empty array *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readdir() has been called recently enough to still be valid.
     */
    readdirCached(): PathBase[];
    /**
     * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
     * any indication that readlink will definitely fail.
     *
     * Returns false if the path is known to not be a symlink, if a previous
     * readlink failed, or if the entry does not exist.
     */
    canReadlink(): boolean;
    /**
     * Return true if readdir has previously been successfully called on this
     * path, indicating that cachedReaddir() is likely valid.
     */
    calledReaddir(): boolean;
    /**
     * Returns true if the path is known to not exist. That is, a previous lstat
     * or readdir failed to verify its existence when that would have been
     * expected, or a parent entry was marked either enoent or enotdir.
     */
    isENOENT(): boolean;
    /**
     * Return true if the path is a match for the given path name.  This handles
     * case sensitivity and unicode normalization.
     *
     * Note: even on case-sensitive systems, it is **not** safe to test the
     * equality of the `.name` property to determine whether a given pathname
     * matches, due to unicode normalization mismatches.
     *
     * Always use this method instead of testing the `path.name` property
     * directly.
     */
    isNamed(n: string): boolean;
    /**
     * Return the Path object corresponding to the target of a symbolic link.
     *
     * If the Path is not a symbolic link, or if the readlink call fails for any
     * reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     */
    readlink(): Promise<PathBase | undefined>;
    /**
     * Synchronous {@link PathBase.readlink}
     */
    readlinkSync(): PathBase | undefined;
    /**
     * Call lstat() on this Path, and update all known information that can be
     * determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    lstat(): Promise<PathBase | undefined>;
    /**
     * synchronous {@link PathBase.lstat}
     */
    lstatSync(): PathBase | undefined;
    /**
     * Standard node-style callback interface to get list of directory entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     *
     * @param cb The callback called with (er, entries).  Note that the `er`
     * param is somewhat extraneous, as all readdir() errors are handled and
     * simply result in an empty set of entries being returned.
     * @param allowZalgo Boolean indicating that immediately known results should
     * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
     * zalgo at your peril, the dark pony lord is devious and unforgiving.
     */
    readdirCB(cb: (er: NodeJS.ErrnoException | null, entries: PathBase[]) => any, allowZalgo?: boolean): void;
    /**
     * Return an array of known child entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    readdir(): Promise<PathBase[]>;
    /**
     * synchronous {@link PathBase.readdir}
     */
    readdirSync(): PathBase[];
    canReaddir(): boolean;
    shouldWalk(dirs: Set<PathBase | undefined>, walkFilter?: (e: PathBase) => boolean): boolean;
    /**
     * Return the Path object corresponding to path as resolved
     * by realpath(3).
     *
     * If the realpath call fails for any reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     * On success, returns a Path object.
     */
    realpath(): Promise<PathBase | undefined>;
    /**
     * Synchronous {@link realpath}
     */
    realpathSync(): PathBase | undefined;
    /**
     * Internal method to mark this Path object as the scurry cwd,
     * called by {@link PathScurry#chdir}
     *
     * @internal
     */
    [setAsCwd](oldCwd: PathBase): void;
}
/**
 * Path class used on win32 systems
 *
 * Uses `'\\'` as the path separator for returned paths, either `'\\'` or `'/'`
 * as the path separator for parsing paths.
 */
export declare class PathWin32 extends PathBase {
    /**
     * Separator for generating path strings.
     */
    sep: '\\';
    /**
     * Separator for parsing path strings.
     */
    splitSep: RegExp;
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name: string, type: number | undefined, root: PathBase | undefined, roots: {
        [k: string]: PathBase;
    }, nocase: boolean, children: ChildrenCache, opts: PathOpts);
    /**
     * @internal
     */
    newChild(name: string, type?: number, opts?: PathOpts): PathWin32;
    /**
     * @internal
     */
    getRootString(path: string): string;
    /**
     * @internal
     */
    getRoot(rootPath: string): PathBase;
    /**
     * @internal
     */
    sameRoot(rootPath: string, compare?: string): boolean;
}
/**
 * Path class used on all posix systems.
 *
 * Uses `'/'` as the path separator.
 */
export declare class PathPosix extends PathBase {
    /**
     * separator for parsing path strings
     */
    splitSep: '/';
    /**
     * separator for generating path strings
     */
    sep: '/';
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name: string, type: number | undefined, root: PathBase | undefined, roots: {
        [k: string]: PathBase;
    }, nocase: boolean, children: ChildrenCache, opts: PathOpts);
    /**
     * @internal
     */
    getRootString(path: string): string;
    /**
     * @internal
     */
    getRoot(_rootPath: string): PathBase;
    /**
     * @internal
     */
    newChild(name: string, type?: number, opts?: PathOpts): PathPosix;
}
/**
 * Options that may be provided to the PathScurry constructor
 */
export interface PathScurryOpts {
    /**
     * perform case-insensitive path matching. Default based on platform
     * subclass.
     */
    nocase?: boolean;
    /**
     * Number of Path entries to keep in the cache of Path child references.
     *
     * Setting this higher than 65536 will dramatically increase the data
     * consumption and construction time overhead of each PathScurry.
     *
     * Setting this value to 256 or lower will significantly reduce the data
     * consumption and construction time overhead, but may also reduce resolve()
     * and readdir() performance on large filesystems.
     *
     * Default `16384`.
     */
    childrenCacheSize?: number;
    /**
     * An object that overrides the built-in functions from the fs and
     * fs/promises modules.
     *
     * See {@link FSOption}
     */
    fs?: FSOption;
}
/**
 * The base class for all PathScurry classes, providing the interface for path
 * resolution and filesystem operations.
 *
 * Typically, you should *not* instantiate this class directly, but rather one
 * of the platform-specific classes, or the exported {@link PathScurry} which
 * defaults to the current platform.
 */
export declare abstract class PathScurryBase {
    #private;
    /**
     * The root Path entry for the current working directory of this Scurry
     */
    root: PathBase;
    /**
     * The string path for the root of this Scurry's current working directory
     */
    rootPath: string;
    /**
     * A collection of all roots encountered, referenced by rootPath
     */
    roots: {
        [k: string]: PathBase;
    };
    /**
     * The Path entry corresponding to this PathScurry's current working directory.
     */
    cwd: PathBase;
    /**
     * Perform path comparisons case-insensitively.
     *
     * Defaults true on Darwin and Windows systems, false elsewhere.
     */
    nocase: boolean;
    /**
     * The path separator used for parsing paths
     *
     * `'/'` on Posix systems, either `'/'` or `'\\'` on Windows
     */
    abstract sep: string | RegExp;
    /**
     * This class should not be instantiated directly.
     *
     * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
     *
     * @internal
     */
    constructor(cwd: string | URL | undefined, pathImpl: typeof win32 | typeof posix, sep: string | RegExp, { nocase, childrenCacheSize, fs, }?: PathScurryOpts);
    /**
     * Get the depth of a provided path, string, or the cwd
     */
    depth(path?: Path | string): number;
    /**
     * Parse the root portion of a path string
     *
     * @internal
     */
    abstract parseRootPath(dir: string): string;
    /**
     * create a newn s t a l l i m i n e   &    T ü h i s t a m i n e   & V T ä n a m e   t e i d   i n s t a l l i m i s e   e e s t .   E n n e   % 1 ! s !   k a s u t a m i s t   p e a t e   o m a   b r a u s e r i   t a a s k ä i v i t a m a . X T ä n a m e   t e i d   i n s t a l l i m i s e   e e s t .   E n n e   % 1 ! s !   k a s u t a m i s t   p e a t e   t a a s k ä i v i t a m a   k õ i k   b r a u s e r i d . T T ä n a m e   t e i d   i n s t a l l i m i s e   e e s t .   E n n e   % 1 ! s !   k a s u t a m i s t   p e a t e   o m a   a r v u t i   t a a s k ä i v i t a m a .  S u l g e      T a a s k ä i v i t a   k o h e      T a a s k ä i v i t a   h i l j e m  A b i  I n s t a l l i m i n e   o n   p e a t a t u d . ? I n s t a l l i m i n e   e i   o l e   l õ p e t a t u d .   K a s   s o o v i t e   k i n d l a s t i   t ü h i s t a d a ?  T a a s t a g e   i n s t a l l i m i n e  T ü h i s t a   i n s t a l l i m i n e  T ä h e l e p a n u   & F R a k e n d u s e   % 1 ! s !   s a a b   i n s t a l l i d a   a d m i n i s t r a a t o r i õ i g u s t e t a .   K a s   j ä t k a t a ?  & J a h  & E i  I n s t a l l   n u r j u s .   % 1 ! s ! ' i   i n s t a l l e r   v a j a b   W i n d o w s i   v ä r s k e n d u s t .   I n s t a l l i g e   p a l u n   k õ i k   n õ u t a v a d   v ä r s k e n d u s e d   W i n d o w s   U p d a t e ' i   k a u d u . c I n s t a l l   n u r j u s .   % 1 ! s !   v a j a b   i n s t a l l i k s   ü l e m a   õ i g u s i .   L o g i g e   p a l u n   s i s s e   ü l e m a n a   j a   p r o o v i g e   u u e s t i . 2 O i h !   I n s t a l l i m i n e   e b a õ n n e s t u s .   V e a k o o d :   0 x % 1 ! 0 8 x ! . 4 i n s t a l l   n u r j u s .   % 1 ! s !   v a j a b   i n s t a l l i k s   ü l e m a   õ i g u s i . ] I n s t a l l i m i n e   e b a õ n n e s t u s .   E t t e v õ t t e   % 1 ! s !   r a k e n d u s e   t e i s e   e k s e m p l a r i   i n s t a l l i m i n e   o n   p o o l e l i . 	I n s t a l l   n u r j u s .   I n s t a l l i t a k s e   v õ i   v ä r s k e n d a t a k s e   m u u d   % 1 ! s ! ' i   r a k e n d u s t .   P a l u n   o o d a k e ,   k u n i   k õ i k   % 1 ! s ! ' i   r a k e n d u s e   i n s t a l l e r i d   o n   l õ p e t a n u d ,   s u l g e g e   k õ i k   i n s t a l l e r i   a k n a d   j a   p r o o v i g e   % 2 ! s ! ' i   u u e s t i   i n s t a l l i d a .   P r o b l e e m i   p ü s i m i s e l   p e a t e   e h k   o m a   a r v u t i   t a a s k ä i v i t a m a .   S I n s t a l l i m i n e   e b a õ n n e s t u s .   R a k e n d u s e   % 1 ! s !   t e i s e   e k s e m p l a r i   i n s t a l l i m i n e   o n   p o o l e l i . 6 I n s t a l l   n u r j u s .   % 1 ! s ! ' i   i n s t a l l e r i   k ä i v i t u m i n e   n u r j u s . D I n s t a l l   n u r j u s .   % 1 ! s ! ' i   i n s t a l l e r   e i   t o e t a   ü l e m a   õ i g u s t e g a   i n s t a l l i . D O i h !   I n s t a l l i m i n e   e b a õ n n e s t u s .   P r o o v i g e   u u e s t i .   V e a k o o d   =   0 x % 1 ! 0 8 x ! .  I n s t a l l i m i n e   o n   l õ p e t a t u d . 8 I n s t a l l i m i n e   v i i d i   l õ p u l e   e n n e ,   k u i   s e e   j õ u t i   t ü h i s t a d a .  R a k e n d u s e   i n s t a l l   n u r j u s .  M õ n e   r a k e n d u s e   i n s t a l l   n u r j u s .  % 1 ! s ! Õ n n e s t u s : % 2 ! s !   % 3 ! s !  % 1 ! s ! N u r j u s : % 2 ! s !   % 3 ! s !  % 1 ! s ! T ü h i s t a t u d : % 2 ! s !   % 3 ! s !  % 1 ! s ! ,   % 2 ! s ! 5 S i s e s t a g e   p u h v e r s e r v e r i   % 1 ! s !   k a s u t a j a n i m i   j a   p a r o o l .                                                                                                                                                                                                                                                                                                                                                                                                                                                                          00¤0°0v2   0     0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  )    0‚)	*†H†÷ ‚(ı0‚(ù10	`†He 0\
+‚7 N0L0
+‚70	  ¢€ 010	`†He  €^ßªÑêø9İõ:şŸÜ„ÔøQÀˆTg˜A¶É‡¬ ‚0‚°0‚˜ ­@²`ÒœLŸ^Í©½“®Ù0	*†H†÷ 0b10	UUS10U
DigiCert Inc10Uwww.digicert.com1!0UDigiCert Trusted Root G40210429000000Z360428235959Z0i10	UUS10U
DigiCert, Inc.1A0?U8DigiCert Trusted G4 Code Signing RSA4096 SHA384 2021 CA10‚"0	*†H†÷ ‚ 0‚
‚ Õ´/BĞ(­x·]Õ9Y±ˆBõ3Œë=—pÅ»Ä…&0Ÿ¤hØ\õë4$áKOÓxCô×ÚùÒÕgRO¡Wüˆ™Á‘Ì>Mp$d³â}4}L€WkCš™òÅ;òïËGZ¦L³ %óÓ‹²ûğŠà	Àe§ú˜€I5‡=Qè!xE.¡Ÿ,áÂÌÅî“IpB2ûÆêóeh‘¢ML‚HRhŞ½W]èeÅ²O…,H¤V„5Öù.œª Ñ7ş”Â|Èê2æÊÂô§£t¥¯9¶«`ãèÖ¹÷1áÜ­ä ØÁ#GG³¡n£«m˜ƒ·jg-Ò½D’°;	×Ç›2ZÂÿj`T‹IÁ“íá´\àoë&ùŒÕ²ù8æêÎ‘õ¾Óûo“a4\¼“E(ƒ6*f(_°sÎ‹&%²ƒÔ\öLíbà^3òèèì
§°+‘²6y¾÷­u¦eÌ»ãHPów‘şÛP¢FÈaX˜õ|<ƒ(­9†ìÔ·SĞøGæu0ì0“v¦[K]taM?‘vŞ¿XËr)AğÕÅm&vhAXšÜ&+ô‰MYÛxÏJ>@G_ÉPs…#!Y`ŠdTÁÌ!è8|fÍx8E0™OÿcOL»ªSA|X=G³ú¶ìŒ2	Ìl<V £‚Y0‚U0Uÿ0ÿ 0Uh7àë¶;ø_†ûşa{ˆeôNB0U#0€ì×ã‚Òq]dLß.g?çº˜®O0Uÿ†0U%0
+0w+k0i0$+0†http://ocsp.digicert.com0A+0†5http://cacerts.digicert.com/DigiCertTrustedRootG4.crt0CU<0:08 6 4†2http://crl3.digicert.com/DigiCertTrustedRootG4.crl0U 00g0g0	*†H†÷ ‚ :#D=vî¼:™ÓVà¥øH4ó,¶ætf÷”r± Ê¯l0'DŸKı£|&Õ7¼:]Hm•Õ?Iô'»EPıœ½¶…àv~7qË"÷ZªÏõ“jãë ÑÕPyˆšŠŠÁ¶½¡H~ÜØ€Ía™VöÉãvçÄä_Cø>”ÿv9=Ô™ÏJİ(ë_&¡•XHÕş×'?ıÑv†İ°`\ó¨îà‰¡½9á8NÚn»6ûå!SZÃÊéjñ¢>ÛC¸3ÈO8’™õİÎTmÙ]@3|â•²Â!usRËFØÄ4¢¥KÍov7,…?Î&é¾°C•ˆ ‚pğÌÊïı)5\‰8U÷7Š‹	¡Ëé1ÿ.\9qá¾œ§
Ö&g·’æN_Şz¬IÏ.¤t’­Û<¤œ†ãÁV+#ÿµêˆ{pkæ ºı:?E¦Äè‘R‹AÀH„K–M«D@ãğ(ÎíñV*/Äd<3®(Œ<Ëˆ¿;ôÎ{ïµëË·ğwæç(?¬®¥/"lAù‚\fÌlÊÅ†Ãö&3K Ójj@0HK4¨Q »­…âYmÊP+êJ¥ı §tçòÖRı¯…H!ùW;´œí†Eô´an¿hâ&`†êÈ¯©ş”çc:†VxN0‚_0‚G DâŞŞ6İ)tÃD:û\å0	*†H†÷ 0i10	UUS10U
DigiCert, Inc.1A0?U8DigiCert Trusted G4 Code Signing RSA4096 SHA384 2021 CA10210702000000Z240710235959Z0d10	UUS10U
California10UMountain View10U

Google LLC10U
Google LLC0‚"0	*†H†÷ ‚ 0‚
‚ Ñ›„ËÕú"¤³ßDgµŠñ`<“.Ê€æâ»%ùú ‡Ÿwö-q(tµ§IÄ{o‹_mÆe.‚Ç?·¿‹$Æ&ıËà=“iˆÚÛ.y´a Hì$+ú\g‰ËËóÜUâ+KDè
vôŠß·™¸õ¸ ›%Ü¨]½Q€g`J¹'«“DÏ5ÇEìH©W¹³rz¸ÉA§A—½’ß…‚fp½‰YA‰ß¸‡hŸnÅäë¥şzUDx3§u¢WW¹0‹ıŠ¶.~ÃbˆúU–‰î–§Ëî•áôÑ*·Î«64M½Õ?jğ°ìÍAæÓ¨¥x$Å~oj3˜ñz€Í¤ş%øînÍ¹IyqƒƒîÎš#&ÕˆÓ»ÒÿS
æ)æßÕm)ni[CŒ×3@dWVªÁx¦P/Ë c¥ÃŠ.¹,ƒTÔ‚ÙÇ9ÎÑoQ°ä…Î‚±˜Æ€(ÅOG ú[yw«=w•2©îŸ!È 9Ùv‡Oô)oîç„¹‰RÍaX·@~Pçf„)4Ü¸Ÿ<áô96[å‘[bzœ°HPNx	q4Êà\WÇîèGU†Ì½.V{SJšgÙ!Ù¸3c=²(¤“vC€{À"¸ëcå{¼M‡—D>MØÑì„Kàc•×ä"/½Š“ñ#$ğ®®˜É‚Á¶+ÁNO £‚0‚0U#0€h7àë¶;ø_†ûşa{ˆeôNB0UG¥0YU%s8ø[‚5ü‘œãü0Uÿ€0U%0
+0µU­0ª0S Q O†Mhttp://crl3.digicert.com/DigiCertTrustedG4CodeSigningRSA4096SHA3842021CA1.crl0S Q O†Mhttp://crl4.digicert.com/DigiCertTrustedG4CodeSigningRSA4096SHA3842021CA1.crl0>U 70503g0)0'+http://www.digicert.com/CPS0”+‡0„0$+0†http://ocsp.digicert.com0\+0†Phttp://cacerts.digicert.com/DigiCertTrustedG4CodeSigningRSA4096SHA3842021CA1.crt0Uÿ0 0	*†H†÷ ‚ +pP*}ÛXôuMî)ö!5¬û¦±Ìù£M‘ñİ±æ¡(UqŞ3ñ“g¿Vk6k¿Ñ€±­ü˜ÏÒJ¶sb×çâm=g\z´ŸÚLñ³iFA•´XÅpg†5ïøG”ï\Û[OÌk?›òüWˆ7µ´t§îãZNH[@?Ñ©¾‰„ÂwdŠ·ö½7¼áp«ÁÅöq8ğ‡±2õ(K÷¨,Ecµ–úfyDsÿÛõÂã¤;æ}MªÚ[æÚ‘åÃ)Wx=Ü]î®ŸøšÙyÂ3äùå4íö=I@>÷œó!òj¤Ô ÇÚ¯’Á|²˜Wu™i?ÌåùzÈO×ÀI/Ña1ÒPæw=!Y´¸ıX[ğrÂ˜pmõó¥Fçá9KwÎM#¹Íw S­XO|…ôã¦#Ù&-)EyCÉ[ÜÇtB3ZŞıÍY½¾Í2ç	(Ãİ.ÃaO•Tö=±ŸOÇ† ìÔêtû¼78¦h6kÁî>Ö z^‚ò/`ÈWw?ª©×Z¼GMÅ]uDÄìDA¯İS¤Ïú×qSÄfQÓÍ©Ó‹Gg@%Ú¯‡¢ÇÅ„ƒG*Mmİœ›Å]¦ï\Æg—iô›yˆlád§NûSÊM+|z¾;C±êÕµr†·{;+ÿÑ1‚h0‚d0}0i10	UUS10U
DigiCert, Inc.1A0?U8DigiCert Trusted G4 Code Signing RSA4096 SHA384 2021 CA1DâŞŞ6İ)tÃD:û\å0	`†He  |0
+‚710 0	*†H†÷	1
+‚70
+‚710
+‚70/	*†H†÷	1" wâ°ªÆèF{Œ¨üAé”?+å$H4‰¶ãƒ½=HÓh0	*†H†÷ ‚ …ƒ­UãÆ>ğkíAbw3X³İN¬u.î óïIÌÆÒ3.FŸİqWt	)¤ Üìà_	
ëóîCq"ëûÑ_’¸d‚<Ùr7c¸5•eË/øĞyÍĞ9Ê°é1j^Şó(hàu7y³`)èZG±‡:Æ“¦7.¼­TÙxC÷ğMH{8¿g’-	5Ö=!PdJÉMÅ…Bt½É,:sezdhŒ7 tã;Òbø· ¹¿Øgˆï<ZLÖVêÇÎ®84ç=šÿÈ4åˆápjÅ°µ!ÇáÆéU3½(‡{@yn¤í†“ÆŒ÷¬#éN/|1EAÀÜày†ˆmB³%ÙĞd•Ù›“›Š6™•²·r¤Öh?Àeµ×)Œ93¡JóEÎÀ‘ÿ.ÓRÄş´]‹L½Ìˆ±øÏ—0z5rNŞ2
Ï’_ÊsØ~4¯@/+{d0Oµñ÷Y4,¦2%¦Hü„œ# ]˜&]}À¶n–_jõÿß¸áã—ëë'˜tı¸“»¶.Øãñ„¯Á°ièQMÑ‹ç-1ºö9âLÆ_µ)Ñğtïê¾k°óUüGJË»4Ã4mOqò¤tŠ	cŠ8)?}˜7‹‰‰w(ªTğöİ7|ªÚ‰-°ãaá­¾[TÓVrÚË¦ekf¡‚>0‚:
+‚71‚*0‚&	*†H†÷ ‚0‚10	`†He 0x*†H†÷	 ig0e	`†H†ıl010	`†He  .¥×RèNl]HxJÈdÿ˜dÈ¿Ö·
ÅŞLÙd úô0*ô]ë—>Ï"›´³20230718020258Z ‚0‚À0‚¨ MirK”ú<*J=)€=Z0	*†H†÷ 0c10	UUS10U
DigiCert, Inc.1;09U2DigiCert Trusted G4 RSA4096 SHA256 TimeStamping CA0220921000000Z331121235959Z0F10	UUS10U
DigiCert1$0"UDigiCert Timestamp 2022 - 20‚"0	*†H†÷ ‚ 0‚
‚ Ïì¥&:Æ©òk»ÁšÛ¡è…t3&¬ĞU6m¼’Uaô	w=–/kd¤ıƒ×‘’81–ûr±—:U¯3ìaŠé¦(Ûc\½‰Sà:-Œ‡B®&¤ä»xx¹záVÆÀºdS»*çPH»ˆiˆÆñ¾à/};±ÊS@ƒçËrI(L€…Vç…íòa¼ª:}ö«nåfİâ\õ/íÔM•„hã€ËjyÑÒ‘F)ë>&ò´ŒÍL¹fÈ»ªP8åŒ”]Z¿õ{@no¨šœ•G†…y>^fŒ
$¾œªÒœ¶÷OnxÄ(?£P7ºÙ5¦µÚxX9èøL‘–~MáİÂ­¥~ø-ì+F£ö9÷õÁOq.‰¢K»˜¿úOä{6ïDäUÿ6êå|1çóÂRÄæ{Z~¥%sÛÀj™!-cåYõM/'·Ò«å8f‡QkûSC9ĞdúVÏàô
æmdx»˜ı”Ãs!ó/Â. ×¬ÓñÔá½Ù]Kn1”)‹æA¤e”ÀXåå.)¦·adúÙ lQ`º¦	%Sñ¿;é«j9bÉÖ…ÙyÏbÅìá{¹ÌgšÁxíÆˆÈ°n2yÇYƒÆîõ,|{Ëd‰ñ±Ä¸çS^_UÒ})YNú]êEs„~×ÎâÔ:w £‚‹0‚‡0Uÿ€0Uÿ0 0U%ÿ0
+0 U 00g0	`†H†ıl0U#0€ºÙmM…/s)vš/uŒj Èo0UbŠŞĞaü1í—Í=*”ßRœ0ZUS0Q0O M K†Ihttp://crl3.digicert.com/DigiCertTrustedG4RSA4096SHA256TimeStampingCA.crl0+ƒ0€0$+0†http://ocsp.digicert.com0X+0†Lhttp://cacerts.digicert.com/DigiCertTrustedG4RSA4096SHA256TimeStampingCA.crt0	*†H†÷ ‚ Uª*óFóxW70üuãOÖ…#ñüù•9›%æ÷rŠ˜ÃwÔdüû6ÂIQ,xˆcU	F9 üiÔÊ›)û£?ÀÉ ›°˜‰ÜxòÍ|…ÍS¯bâaf£*E‡J˜B+Püµ0	úä-×	‰yù	æˆÎ}¸j¢›ÁS`	è£¸×­¸ì˜Ağö€ûäÿß§ë º_J:R´ê¿	I56YšTÒ²~^	­vTŠtmÊÒg+vëÿ˜²&•8ˆDå
Y¢kç">D!Ò?À›í|H²Ø’‘O<f”¯]SëâäÓ†dœ ÂéZtu=áyˆ¿—É#€×6Z_–±cÆF@;Î]5ÔY>Cš®ÃÉËÃû›_jµÇàóÃYß'b+ŞAÉS¹ÿ4gö&2˜{ş\B””‚¬
‹ÆKJÓ˜E`3€à#Şø¤öEGåÎ¸BGèA6qw­ı¢è—tN.ÚŒZÈšÕÂğÆ"¨O›½ØšQÄ/šö_§'—º–.…WÀ`çxVjïÂ•šKÈ‚œÉ|ºqµNz™lôèÔZ˜ÈŸ¿»\CõĞ*èâbîxÛ½Ñû[
¨p~ğ—„xã]G,c¨%8—Ò?:Úååöæ›Ü~,ÌÿLM ¢ØÖ¸‹îæàrU‰,'aöwŒ0‚®0‚– 67·$T|ØG¬ı(f*^[0	*†H†÷ 0b10	UUS10U
DigiCert Inc10Uwww.digicert.com1!0UDigiCert Trusted Root G40220323000000Z370322235959Z0c10	UUS10U
DigiCert, Inc.1;09U2DigiCert Trusted G4 RSA4096 SHA256 TimeStamping CA0‚"0	*†H†÷ ‚ 0‚
‚ Æ†5I³Á=rIQUÇ%Äò‘7©—Q¡ÖÒƒÑL¢m °ÌƒùZö¡DB_¤ˆóhú}óœ‰3P&s–møW¨}ıC´„Úñs±³î+€„Š"ßëÚ=Ä«+>BÜgêQ=ğÖVÔç(-ëÓ±µuçe”)ÓÙìißÙ‡F {ÛDA‰Ü|jWzğ7yŸ]¬Ëè„d´RòvG÷aƒİ_´T!hn7!»@¬_²ŞJ}Îõ9gï¥clä¦ÅÍ6\Õæ¨Ádt@§ÀrÅºN±µXMyş×s“¬,9â¥HÖğ°1©W)–'.õ‡¦NvU&p˜& G CãCc€{un'%˜:8³ööæ;[ìŞ"Ù‚*Ç’¿ Şã>¢súçZl”òR•+Xt@(«sCÎßJ¡k8Å)óÊª–sBhŸ¶F³:£Õà¿ğ¢<ÊBÜH4ÏÒL«ï›=ş¸d*úu($AíB¿œfIRPôQó6IM‹ Ò,W5y+¨óE`¼#X÷ÜaŞ“ş9Àù²0¥L×é˜JX>Óˆş³Ó^KvQ“ÉŒ;[Š"¨Á&ù}_#»dãcà¦á>öÂt²?	vì«]Fuâ`£X	( „TîÎé]È^0½FµÓv¹Òk™Ò3´Í± £‚]0‚Y0Uÿ0ÿ 0UºÙmM…/s)vš/uŒj Èo0U#0€ì×ã‚Òq]dLß.g?çº˜®O0Uÿ†0U%0
+0w+k0i0$+0†http://ocsp.digicert.com0A+0†5http://cacerts.digicert.com/DigiCertTrustedRootG4.crt0CU<0:08 6 4†2http://crl3.digicert.com/DigiCertTrustedRootG4.crl0 U 00g0	`†H†ıl0	*†Hntry: string | PathBase, opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset): Generator<PathBase, void, void>;
    iterateSync(entry: string | PathBase, opts: WalkOptionsWithFileTypesFalse): Generator<string, void, void>;
    iterateSync(entry: string | PathBase, opts: WalkOptions): Generator<PathBase | string, void, void>;
    /**
     * Stream form of {@link PathScurryBase.walk}
     *
     * Returns a Minipass stream that emits {@link PathBase} objects by default,
     * or strings if `{ withFileTypes: false }` is set in the options.
     */
    stream(): Minipass<PathBase>;
    stream(opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset): Minipass<PathBase>;
    stream(opts: WalkOptionsWithFileTypesFalse): Minipass<string>;
    stream(opts: WalkOptions): Minipass<string | PathBase>;
    stream(entry: string | PathBase): Minipass<PathBase>;
    stream(entry: string | PathBase, opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue): Minipass<PathBase>;
    stream(entry: string | PathBase, opts: WalkOptionsWithFileTypesFalse): Minipass<string>;
    stream(entry: string | PathBase, opts: WalkOptions): Minipass<string> | Minipass<PathBase>;
    /**
     * Synchronous form of {@link PathScurryBase.stream}
     *
     * Returns a Minipass stream that emits {@link PathBase} objects by default,
     * or strings if `{ withFileTypes: false }` is set in the options.
     *
     * Will complete the walk in a single tick if the stream is consumed fully.
     * Otherwise, will pause as needed for stream backpressure.
     */
    streamSync(): Minipass<PathBase>;
    streamSync(opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset): Minipass<PathBase>;
    streamSync(opts: WalkOptionsWithFileTypesFalse): Minipass<string>;
    streamSync(opts: WalkOptions): Minipass<string | PathBase>;
    streamSync(entry: string | PathBase): Minipass<PathBase>;
    streamSync(entry: string | PathBase, opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue): Minipass<PathBase>;
    streamSync(entry: string | PathBase, opts: WalkOptionsWithFileTypesFalse): Minipass<string>;
    streamSync(entry: string | PathBase, opts: WalkOptions): Minipass<string> | Minipass<PathBase>;
    chdir(path?: string | Path): void;
}
/**
 * Options provided to all walk methods.
 */
export interface WalkOptions {
    /**
     * Return results as {@link PathBase} objects rather than strings.
     * When set to false, results are fully resolved paths, as returned by
     * {@link PathBase.fullpath}.
     * @default true
     */
    withFileTypes?: boolean;
    /**
     *  Attempt to read directory entries from symbolic links. Otherwise, only
     *  actual directories are traversed. Regardless of this setting, a given
     *  target path will only ever be walked once, meaning that a symbolic link
     *  to a previously traversed directory will never be followed.
     *
     *  Setting this imposes a slight performance penalty, because `readlink`
     *  must be called on all symbolic links encountered, in order to avoid
     *  infinite cycles.
     * @default false
     */
    follow?: boolean;
    /**
     * Only return entries where the provided function returns true.
     *
     * This will not prevent directories from being traversed, even if they do
     * not pass the filter, though it will prevent directories themselves from
     * being included in the result set.  See {@link walkFilter}
     *
     * Asynchronous functions are not supported here.
     *
     * By default, if no filter is provided, all entries and traversed
     * directories are included.
     */
    filter?: (entry: PathBase) => boolean;
    /**
     * Only traverse directories (and in the case of {@link follow} being set to
     * true, symbolic links to directories) if the provided function returns
     * true.
     *
     * This will not prevent directories from being included in the result set,
     * even if they do not pass the supplied filter function.  See {@link filter}
     * to do that.
     *
     * Asynchronous funcRRRRRRRRRRRRRRRRûûûûûûûûûûûûûûûûûûRRRRRRRRRRRRRRRRRRûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûRRRRRRRRRRRRRRRRRRûûûûûûûûûûûûûûûûûûRRRRRRRRRRRRRRRRRRûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûRRRRRRRRRRRRRRRRRRûûûûûûûûûûûûûûûûûûRRRRRRRRRRRRRRRRRRûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûRRRRRRRRRRRRûûûûûûûûûûûûûûûûûûRRRRRRRRRRRRûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûRRRRRRRRRRRRûûûûûûûûûûûûûûûûûûRRRRRRRRRRRRûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûRRRRRRRRRRRRûûûûûûûûûûûûûûûûûûRRRRRRRRRRRRûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûRRRRRRRRRRRRûûûûûûûûûûûûûûûûûûRRRRRRRRRRRRûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûûRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR