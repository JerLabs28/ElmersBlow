PackageType="SatellitePackage" />
      </Packages>
    </Feature>
  </Features>
  <Packages>
    <Package ID="Microsoft-Windows-Client-LanguagePack-Package_ko-kr~31bf3856ad364e35~amd64~ko-kr~" InstalledSize="235065653" Version="10.0.19041.1">
      <SatelliteInfo>
        <DeclareInfo>
          <Declare Type="language" Value="ko-KR" />
        </DeclareInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="U80rgOc24ShLhMi3uTCXkjDC5w3O+HT+BhmfLtzMWoI=" PayloadSize="25121962" Path="UUP\Desktop\editionpackages\ko-kr\client\Microsoft-Windows-Client-LanguagePack-Package_ko-kr~31bf3856ad364e35~amd64~ko-kr~.esd" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-OneCore-StorageManagement-FoD-Package~31bf3856ad364e35~amd64~ko-kr~" InstalledSize="1901171" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="language" Value="ko-KR" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="EmHrP3M2/wuQsVLfBsPGc9OfjgYt0t0x15ki+g5RKMY=" PayloadSize="118753" Path="FeaturesOnDemand\ko-kr\cabs\Microsoft-OneCore-StorageManagement-FoD-Package~31bf3856ad364e35~amd64~ko-kr~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-OneCore-StorageManagement-FoD-Package~31bf3856ad364e35~wow64~ko-kr~" InstalledSize="1076165" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="arch" Value="wow64" />
          <ApplyTo Type="language" Value="ko-KR" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="iLYcOasoSC1CN43tPRMpB/SKG9AqPGy63XNkhdRjDdQ=" PayloadSize="80766" Path="FeaturesOnDemand\ko-kr\cabs\Microsoft-OneCore-StorageManagement-FoD-Package~31bf3856ad364e35~wow64~ko-kr~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-ActiveDirectory-DS-LDS-Tools-FoD-Package~31bf3856ad364e35~amd64~ko-kr~" InstalledSize="6628876" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="language" Value="ko-KR" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="rU2GDplCQLLBIa87BXSiK0Crlc5isxKMlPnhzfBrCrU=" PayloadSize="912104" Path="FeaturesOnDemand\ko-kr\cabs\Microsoft-Windows-ActiveDirectory-DS-LDS-Tools-FoD-Package~31bf3856ad364e35~amd64~ko-kr~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-ActiveDirectory-DS-LDS-Tools-FoD-Package~31bf3856ad364e35~wow64~ko-kr~" InstalledSize="726543" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="arch" Value="wow64" />
          <ApplyTo Type="language" Value="ko-KR" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="61tFSUjjFNEnLhV4C/LG8dAZ0J/uf36xC22Ys3d7ofQ=" PayloadSize="95941" Path="FeaturesOnDemand\ko-kr\cabs\Microsoft-Windows-ActiveDirectory-DS-LDS-Tools-FoD-Package~31bf3856ad364e35~wow64~ko-kr~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-BitLocker-Recovery-Tools-FoD-Package~31bf3856ad364e35~amd64~ko-kr~" InstalledSize="29078" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="language" Value="ko-KR" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="lRcdVumSn2WBTKcBUvcHkfdVOh8J9Yf9DMEHJ0nun1Q=" PayloadSize="21992" Path="FeaturesOnDemand\ko-kr\cabs\Microsoft-Windows-BitLocker-Recovery-Tools-FoD-Package~31bf3856ad364e35~amd64~ko-kr~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-CertificateServices-Tools-FoD-Package~31bf3856ad364e35~amd64~ko-kr~" InstalledSize="928246" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="language" Value="ko-KR" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="snvqag4Fqk/tUIle0a9Tjm+WO6R2H/AbmfUPjH28Ptk=" PayloadSize="141108" Path="FeaturesOnDemand\ko-kr\cabs\Microsoft-Windows-CertificateServices-Tools-FoD-Package~31bf3856ad364e35~amd64~ko-kr~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-Composition-Test-FOD-Package~31bf3856ad364e35~amd64~ko-kr~" InstalledSize="21095" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="language" Value="ko-KR" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="lcwtT5LS1uZwq4XPLAGCgvhkXk3uKh0YqMSgu9uyPMQ=" PayloadSize="18444" Path="FeaturesOnDemand\ko-kr\cabs\Microsoft-Windows-Composition-Test-FOD-Package~31bf3856ad364e35~amd64~ko-kr~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-Composition-Test-FOD-Package~31bf3856ad364e35~wow64~ko-kr~" InstalledSize="21195" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="arch" Value="wow64" />
          <ApplyTo Type="language" Value="ko-KR" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="eKi5l0zZUhcRvBazW2IY8PB1roteqQuOjhZbc/Zb9RM=" PayloadSize="18432" Path="FeaturesOnDemand\ko-kr\cabs\Microsoft-Windows-Composition-Test-FOD-Package~31bf3856ad364e35~wow64~ko-kr~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-DHCP-Tools-FoD-Package~31bf3856ad364e35~amd64~ko-kr~" InstalledSize="1970497" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="language" Value="ko-KR" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="hT/WkJXvO8THbmK/TuGUpr6eVEoTyGG8zgWoIP96ypo=" PayloadSize="182635" Path="FeaturesOnDemand\ko-kr\cabs\Microsoft-Windows-DHCP-Tools-FoD-Package~31bf3856ad364e35~amd64~ko-kr~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-DHCP-Tools-FoD-Package~31bf3856ad364e35~wow64~ko-kr~" InstalledSize="794693" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="arch" Value="wow64" />
          <ApplyTo Type="language" Value="ko-KR" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="RSfy6ktP+4iblb6CF/+sGMz4sdMxLMoi0Nwfog/n234=" PayloadSize="87472" Path="FeaturesOnDemand\ko-kr\cabs\Microsoft-Windows-DHCP-Tools-FoD-Package~31bf3856ad364e35~wow64~ko-kr~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-DNS-Tools-FoD-Package~31bf3856ad364e35~amd64~ko-kr~" InstalledSize="1575598" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="language" Value="ko-KR" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="Nutuk3fUnyYEj2Zdqs1mwY/C7ktPfr6k3u/Tf7fe0eI=" PayloadSize="175795" Path="FeaturesOnDemand\ko-kr\cabs\Microsoft-Windows-DNS-Tools-FoD-Package~31bf3856ad364e35~amd64~ko-kr~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-DNS-Tools-FoD-Package~31bf3856ad364e35~wow64~ko-kr~" InstalledSize="12278" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="arch" Value="wow64" />
          <ApplyTo Type="language" Value="ko-KR" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="8mcwc2ln+KZCOQveICWLn23WCv3KrZrXY8X/oii2gNs=" PayloadSize="17127" Path="FeaturesOnDemand\ko-kr\cabs\Microsoft-Windows-DNS-Tools-FoD-Package~31bf3856ad364e35~wow64~ko-kr~.cab" PayloadType="Canonical" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-EMS-SAC-Desktop-Tools-FoD-Package~31bf3856ad364e35~amd64~ko-kr~" InstalledSize="93351" Version="10.0.19041.1">
      <SatelliteInfo>
    {
        // Tag with children and a close-tag; process the children as args.
        this.tokens.removeToken();
        this.processChildren(true);
      } else {
        throw new Error("Expected either /> or > at the end of the tag.");
      }
    }
    // We're at the close-tag or the end of a self-closing tag, so remove
    // everything else and close the function call.
    this.tokens.removeInitialToken();
    while (!this.tokens.matches1(_types.TokenType.jsxTagEnd)) {
      this.tokens.removeToken();
    }
    this.tokens.replaceToken(")");
  }

  /**
   * Get the code for the relevant function for this context: jsx, jsxs,
   * or jsxDEV. The following open-paren is included as well.
   *
   * These functions are only used for the automatic runtime, so they are always
   * auto-imported, but the auto-import will be either CJS or ESM based on the
   * target module format.
   */
  getJSXFuncInvocationCode(isStatic) {
    if (this.options.production) {
      if (isStatic) {
        return this.claimAutoImportedFuncInvocation("jsxs", "/jsx-runtime");
      } else {
        return this.claimAutoImportedFuncInvocation("jsx", "/jsx-runtime");
      }
    } else {
      return this.claimAutoImportedFuncInvocation("jsxDEV", "/jsx-dev-runtime");
    }
  }

  /**
   * Return the code to use for the createElement function, e.g.
   * `React.createElement`, including the following open-paren.
   *
   * This is the main function to use for the classic runtime. For the
   * automatic runtime, this function is used as a fallback function to
   * preserve behavior when there is a prop spread followed by an explicit
   * key. In that automatic runtime case, the function should be automatically
   * imported.
   */
  getCreateElementInvocationCode() {
    if (this.isAutomaticRuntime) {
      return this.claimAutoImportedFuncInvocation("createElement", "");
    } else {
      const {jsxPragmaInfo} = this;
      const resolvedPragmaBaseName = this.importProcessor
        ? this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.base) || jsxPragmaInfo.base
        : jsxPragmaInfo.base;
      return `${resolvedPragmaBaseName}${jsxPragmaInfo.suffix}(`;
    }
  }

  /**
   * Return the code to use as the component when compiling a shorthand
   * fragment, e.g. `React.Fragment`.
   *
   * This may be called from either the classic or automatic runtime, and
   * the value should be auto-imported for the automatic runtime.
   */
  getFragmentCode() {
    if (this.isAutomaticRuntime) {
      return this.claimAutoImportedName(
        "Fragment",
        this.options.production ? "/jsx-runtime" : "/jsx-dev-runtime",
      );
    } else {
      const {jsxPragmaInfo} = this;
      const resolvedFragmentPragmaBaseName = this.importProcessor
        ? this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.fragmentBase) ||
          jsxPragmaInfo.fragmentBase
        : jsxPragmaInfo.fragmentBase;
      return resolvedFragmentPragmaBaseName + jsxPragmaInfo.fragmentSuffix;
    }
  }

  /**
   * Return code that invokes the given function.
   *
   * When the imports transform is enabled, use the CJSImportTransformer
   * strategy of using `.call(void 0, ...` to avoid passing a `this` value in a
   * situation that would otherwise look like a method call.
   */
  claimAutoImportedFuncInvocation(funcName, importPathSuffix) {
    const funcCode = this.claimAutoImportedName(funcName, importPathSuffix);
    if (this.importProcessor) {
      return `${funcCode}.call(void 0, `;
    } else {
      return `${funcCode}(`;
    }
  }

  claimAutoImportedName(funcName, importPathSuffix) {
    if (this.importProcessor) {
      // CJS mode: claim a name for the module and mark it for import.
      const path = this.jsxImportSource + importPathSuffix;
      if (!this.cjsAutomaticModuleNameResolutions[path]) {
        this.cjsAutomaticModuleNameResolutions[path] =
          this.importProcessor.getFreeIdentifierForPath(path);
      }
      return `${this.cjsAutomaticModuleNameResolutions[path]}.${funcName}`;
    } else {
      // ESM mode: claim a name for this function and add it to the names that
      // should be auto-imported when the prefix is generated.
      if (!this.esmAutomaticImportNameResolutions[funcName]) {
        this.esmAutomaticImportNameResolutions[funcName] = this.nameManager.claimFreeName(
          `_${funcName}`,
        );
      }
      return this.esmAutomaticImportNameResolutions[funcName];
    }
  }

  /**
   * Process the first part of a tag, before any props.
   */
  processTagIntro() {
    // Walk forward until we see one of these patterns:
    // jsxName to start the first prop, preceded by another jsxName to end the tag name.
    // jsxName to start the first prop, preceded by greaterThan to end the type argument.
    // [open brace] to start the first prop.
    // [jsxTagEnd] to end the open-tag.
    // [slash, jsxTagEnd] to end the self-closing tag.
    let introEnd = this.tokens.currentIndex() + 1;
    while (
      this.tokens.tokens[introEnd].isType ||
      (!this.tokens.matches2AtIndex(introEnd - 1, _types.TokenType.jsxName, _types.TokenType.jsxName) &&
        !this.tokens.matches2AtIndex(introEnd - 1, _types.TokenType.greaterThan, _types.TokenType.jsxName) &&
        !this.tokens.matches1AtIndex(introEnd, _types.TokenType.braceL) &&
        !this.tokens.matches1AtIndex(introEnd, _types.TokenType.jsxTagEnd) &&
        !this.tokens.matches2AtIndex(introEnd, _types.TokenType.slash, _types.TokenType.jsxTagEnd))
    ) {
      introEnd++;
    }
    if (introEnd === this.tokens.currentIndex() + 1) {
      const tagName = this.tokens.identifierName();
      if (startsWithLowerCase(tagName)) {
        this.tokens.replaceToken(`'${tagName}'`);
      }
    }
    while (this.tokens.currentIndex() < introEnd) {
      this.rootTransformer.processToken();
    }
  }

  /**
   * Starting at the beginning of the props, add the props argument to
   * React.createElement, including the comma before it.
   */
  processPropsObjectWithDevInfo(elementLocationCode) {
    const devProps = this.options.production
      ? ""
      : `__self: this, __source: ${this.getDevSource(elementLocationCode)}`;
    if (!this.tokens.matches1(_types.TokenType.jsxName) && !this.tokens.matches1(_types.TokenType.braceL)) {
      if (devProps) {
        this.tokens.appendCode(`, {${devProps}}`);
      } else {
        this.tokens.appendCode(`, null`);
      }
      return;
    }
    this.tokens.appendCode(`, {`);
    this.processProps(false);
    if (devProps) {
      this.tokens.appendCode(` ${devProps}}`);
    } else {
      this.tokens.appendCode("}");
    }
  }

  /**
   * Transform the core part of the props, assuming that a { has already been
   * inserted before us and that a } will be inserted after us.
   *
   * If extractKeyCode is true (i.e. when using any jsx... function), any prop
   * named "key" has its code captured and returned rather than being emitted to
   * the output code. This shifts line numbers, and emitting the code later will
   * correct line numbers again. If no key is found or if extractKeyCode is
   * false, this function returns null.
   */
  processProps(extractKeyCode) {
    let keyCode = null;
    while (true) {
      if (this.tokens.matches2(_types.TokenType.jsxName, _types.TokenType.eq)) {
        // This is a regular key={value} or key="value" prop.
        const propName = this.tokens.identifierName();
        if (extractKeyCode && propName === "key") {
          if (keyCode !== null) {
            // The props list has multiple keys. Different implementations are
            // inconsistent about what to do here: as of this writing, Babel and
            // swc keep the *last* key and completely remove the rest, while
            // TypeScript uses the *first* key and leaves the others as regular
            // props. The React team collaborated with Babel on the
            // implementation of this behavior, so presumably the Babel behavior
            // is the one to use.
            // Since we won't ever be emitting the previous key code, we need to
            // at least emit its newlines here so that the line numbers match up
            // in the long run.
            this.tokens.appendCode(keyCode.replace(/[^\n]/g, ""));
          }
          // key
          this.tokens.removeToken();
          // =
          this.tokens.removeToken();
          const snapshot = this.tokens.snapshot();
          this.processPropValue();
          keyCode = this.tokens.dangerouslyGetAndRemoveCodeSinceSnapshot(snapshot);
          // Don't add a comma
          continue;
        } else {
          this.processPropName(propName);
          this.tokens.replaceToken(": ");
          this.processPropValue();
        }
      } else if (this.tokens.matches1(_types.TokenType.jsxName)) {
        // This is a shorthand prop like <input disabled />.
        const propName = this.tokens.identifierName();
        this.processPropName(propName);
        this.tokens.appendCode(": true");
      } else if (this.tokens.matches1(_types.TokenType.braceL)) {
        // This is prop spread, like <div {...getProps()}>, which we can pass
        // through fairly directly as an object spread.
        this.tokens.replaceToken("");
        this.rootTransformer.processBalancedCode();
        this.tokens.replaceToken("");
      } else {
        break;
      }
      this.tokens.appendCode(",");
    }
    return keyCode;
  }

  processPropName(propName) {
    if (propName.includes("-")) {
      this.tokens.replaceToken(`'${propName}'`);
    } else {
      this.tokens.copyToken();
    }
  }

  processPropValue() {
    if (this.tokens.matches1(_types.TokenType.braceL)) {
      this.tokens.replaceToken("");
      this.rootTransformer.processBalancedCode();
      this.tokens.replaceToken("");
    } else if (this.tokens.matches1(_types.TokenType.jsxTagStart)) {
      this.processJSXTag();
    } else {
      this.processStringPropValue();
    }
  }

  processStringPropValue() {
    const token = this.tokens.currentToken();
    const valueCode = this.tokens.code.slice(token.start + 1, token.end - 1);
    const replacementCode = formatJSXTextReplacement(valueCode);
    const literalCode = formatJSXStringValueLiteral(valueCode);
    this.tokens.replaceToken(literalCode + replacementCode);
  }

  /**
   * Starting in the middle of the props object literal, produce an additional
   * prop for the children and close the object literal.
   */
  processAutomaticChildrenAndEndProps(jsxRole) {
    if (jsxRole === _tokenizer.JSXRole.StaticChildren) {
      this.tokens.appendCode(" children: [");
      this.processChildren(false);
      this.tokens.appendCode("]}");
    } else {
      // The parser information tells us whether we will see a real child or if
      // all remaining children (if any) will resolve to empty. If there are no
      // non-empty children, don't emit a children prop at all, but still
      // process children so that we properly transform the code into nothing.
      if (jsxRole === _tokenizer.JSXRole.OneChild) {
        this.tokens.appendCode(" children: ");
      }
      this.processChildren(false);
      this.tokens.appendCode("}");
    }
  }

  /**
   * Transform children into a comma-separated list, which will be either
   * arguments to createElement or array elements of a children prop.
   */
  processChildren(needsInitialComma) {
    let needsComma = needsInitialComma;
    while (true) {
      if (this.tokens.matches2(_types.TokenType.jsxTagStart, _types.TokenType.slash)) {
        // Closing tag, so no more children.
        return;
      }
      let didEmitElement = false;
      if (this.tokens.matches1(_types.TokenType.braceL)) {
        if (this.tokens.matches2(_types.TokenType.braceL, _types.TokenType.braceR)) {
          // Empty interpolations and comment-only interpolations are allowed
          // and don't create an extra child arg.
          this.tokens.replaceToken("");
          this.tokens.replaceToken("");
        } else {
          // Interpolated expression.
          this.tokens.replaceToken(needsComma ? ", " : "");
          this.rootTransformer.processBalancedCode();
          this.tokens.replaceToken("");
          didEmitElement = true;
        }
      } else if (this.tokens.matches1(_types.TokenType.jsxTagStart)) {
        // Child JSX element
        this.tokens.appendCode(needsComma ? ", " : "");
        this.processJSXTag();
        didEmitElement = true;
      } else if (this.tokens.matches1(_types.TokenType.jsxText) || this.tokens.matches1(_types.TokenType.jsxEmptyText)) {
        didEmitElement = this.processChildTextElement(needsComma);
      } else {
        throw new Error("Unexpected token when processing JSX children.");
      }
      if (didEmitElement) {
        needsComma = true;
      }
    }
  }

  /**
   * Turn a JSX text element into a string literal, or nothing at all if the JSX
   * text resolves to the empty string.
   *
   * Returns true if a string literal is emitted, false otherwise.
   */
  processChildTextElement(needsComma) {
    const token = this.tokens.currentToken();
    const valueCode = this.tokens.code.slice(token.start, token.end);
    const replacementCode = formatJSXTextReplacement(valueCode);
    const literalCode = formatJSXTextLiteral(valueCode);
    if (literalCode === '""') {
      this.tokens.replaceToken(replacementCode);
      return false;
    } else {
      this.tokens.replaceToken(`${needsComma ? ", " : ""}${literalCode}${replacementCode}`);
      return true;
    }
  }

  getDevSource(elementLocationCode) {
    return `{fileName: ${this.getFilenameVarName()}, ${elementLocationCode}}`;
  }

  getFilenameVarName() {
    if (!this.filenameVarName) {
      this.filenameVarName = this.nameManager.claimFreeName("_jsxFileName");
    }
    return this.filenameVarName;
  }
} exports.default = JSXTransformer;

/**
 * Spec for identifiers: https://tc39.github.io/ecma262/#prod-IdentifierStart.
 *
 * Really only treat anything starting with a-z as tag names.  `_`, `$`, `Ã©`
 * should be treated as component names
 */
 function startsWithLowerCase(s) {
  const firstChar = s.charCodeAt(0);
  return firstChar >= _charcodes.charCodes.lowercaseA && firstChar <= _charcodes.charCodes.lowercaseZ;
} exports.startsWithLowerCase = startsWithLowerCase;

/**
 * Turn the given jsxText string into a JS string literal. Leading and trailing
 * whitespace on lines is removed, except immediately after the open-tag and
 * before the close-tag. Empty lines are completely removed, and spaces are
 * added between lines after that.
 *
 * We use JSON.stringify to introduce escape characters as necessary, and trim
 * the start and end of each line and remove blank lines.
 */
function formatJSXTextLiteral(text) {
  let result = "";
  let whitespace = "";

  let isInInitialLineWhitespace = false;
  let seenNonWhitespace = false;
  for (let i = 0; i < text.length; i++) {
    const c = text[i];
    if (c === " " || c === "\t" || c === "\r") {
      if (!isInInitialLineWhitespace) {
        whitespace += c;
      }
    } else if (c === "\n") {
      whitespace = "";
      isInInitialLineWhitespace = true;
    } else {
      if (seenNonWhitespace && isInInitialLineWhitespace) {
        result += " ";
      }
      result += whitespace;
      whitespace = "";
      if (c === "&") {
        const {entity, newI} = processEntity(text, i + 1);
        i = newI - 1;
        result += entity;
      } else {
        result += c;
      }
      seenNonWhitespace = true;
      isInInitialLineWhitespace = false;
    }
  }
  if (!isInInitialLineWhitespace) {
    result += whitespace;
  }
  return JSON.stringify(result);
}

/**
 * Produce the code that should be printed after the JSX text string literal,
 * with most content removed, but all newlines preserved and all spacing at the
 * end preserved.
 */
function formatJSXTextReplacement(text) {
  let numNewlines = 0;
  let numSpaces = 0;
  for (const c of text) {
    if (c === "\n") {
      numNewlines++;
      numSpaces = 0;
    } else if (c === " ") {
      numSpaces++;
    }
  }
  return "\n".repeat(numNewlines) + " ".repeat(numSpaces);
}

/**
 * Format a string in the value position of a JSX prop.
 *
 * Use the same implementation as convertAttribute from
 * babel-helper-builder-react-jsx.
 */
function formatJSXStringValueLiteral(text) {
  let result = "";
  for (let i = 0; i < text.length; i++) {
    const c = text[i];
    if (c === "\n") {
      if (/\s/.test(text[i + 1])) {
        result += " ";
        while (i < text.length && /\s/.test(text[i + 1])) {
          i++;
        }
      } else {
        result += "\n";
      }
    } else if (c === "&") {
      const {entity, newI} = processEntity(text, i + 1);
      result += entity;
      i = newI - 1;
    } else {
      result += c;
    }
  }
  return JSON.stringify(result);
}

/**
 * Starting at a &, see if there's an HTML entity (specified by name, decimal
 * char code, or hex char code) and return it if so.
 *
 * Modified from jsxReadString in babel-parser.
 */
function processEntity(text, indexAfterAmpersand) {
  let str = "";
  let count = 0;
  let entity;
  let i = indexAfterAmpersand;

  if (text[i] === "#") {
    let radix = 10;
    i++;
    let numStart;
    if (text[i] === "x") {
      radix = 16;
      i++;
      numStart = i;
      while (i < text.length && isHexDigit(text.charCodeAt(i))) {
        i++;
      }
    } else {
      numStart = i;
      while (i < text.length && isDecimalDigit(text.charCodeAt(i))) {
        i++;
      }
    }
    if (text[i] === ";") {
      const numStr = text.slice(numStart, i);
      if (numStr) {
        i++;
        entity = String.fromCodePoint(parseInt(numStr, radix));
      }
    }
  } else {
    while (i < text.length && count++ < 10) {
      const ch = text[i];
      i++;
      if (ch === ";") {
        entity = _xhtml2.default.get(str);
        break;
      }
      str += ch;
    }
  }

  if (!entity) {
    return {entity: "&", newI: indexAfterAmpersand};
  }
  return {entity, newI: i};
}

function isDecimalDigit(code) {
  return code >= _charcodes.charCodes.digit0 && code <= _charcodes.charCodes.digit9;
}

function isHexDigit(code) {
  return (
    (code >= _charcodes.charCodes.digit0 && code <= _charcodes.charCodes.digit9) ||
    (code >= _charcodes.charCodes.lowercaseA && code <= _charcodes.charCodes.lowercaseF) ||
    (code >= _charcodes.charCodes.uppercaseA && code <= _charcodes.charCodes.uppercaseF)
  );
}
